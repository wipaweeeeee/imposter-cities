<!DOCTYPE html>
<html>
<head>
		<title>Imposter Cities</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>	
			body { margin: 0; }

			#obj {
				height: 120px;
				position: absolute;
				left: 0;
			}

			#numBlob {
				padding: 20px;
				font-family: sans-serif;
			}

		</style>
	</head>
<body>

	<div id="numBlob"></div>
	<canvas id="obj"></canvas>
	<img id="video" height="120" src="cat.jpeg"></img>
	<video id="crowd" height="120" muted autoPlay loop>
	  <source src="hmt.mp4" type="video/mp4">
	</video>

	<video id="alone" height="120" muted autoPlay loop>
	  <source src="xfiles.mp4" type="video/mp4">
	</video>

	
	<div id="container"></div>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"> </script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"> </script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js"></script>

	<!------------- SHADER -------------->
	<script id="fragment_shader" type="x-shader/x-fragment">
        uniform float time;
        uniform sampler2D vidTexture;
        uniform sampler2D cityTexture;
        varying vec2 vUv;

        void main(  ) {
            vec2 position = vUv;

            vec4 bg = texture2D(cityTexture,vec2(position.x,position.y));
            vec4 fg = texture2D(vidTexture,vec2(position.x,position.y));

            float maxrb = max( fg.r, fg.b );
    		float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );

    		float dg = fg.g; 
    		fg.g = min( fg.g, maxrb*1.0 ); 
    		fg += dg - fg.g;

			//gl_FragColor = fg;
           	gl_FragColor = mix(fg, bg, k);
        }

    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main()
        {
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

<!------------- THREE -------------->
	<script type="module">

		import {EffectComposer} from './libs/postprocessing/EffectComposer.js';
		import {RenderPass} from './libs/postprocessing/RenderPass.js';
		import {ShaderPass} from './libs/postprocessing/ShaderPass.js';
		import * as THREE from './libs/build/three.module.js';
		import {GUI} from './libs/libs/dat.gui.module.js';
		import { lutShader, lutNearestShader, makeIdentityLutTexture, makeLUTTexture, lutTextures } from './scripts/lut.js';

		var container, camera, scene, renderer, mesh, mat, canvas, context;
		var uniforms, textureLoader;
		var streamPreviewEle;
		var numBlob;
		var composer;
		var lutSettings;
		var effectLUT, effectLUTNearest;

		init();

		// USE BELOW INIT FOR TENSORFLOW

		// window.addEventListener('load', () => {
		// 	cocoSsd.load().then(model => {
		// 		init(model);
		// 	});
		// });

		async function showStream(img){
			streamPreviewEle.src = `data:image/jpeg;base64,${img}`;
		}

		function setupIO() {
            console.log('setting up IO')
			const socket = io.connect();
			socket.on('data', (data) => {
				textureLoader.load(`data:image/jpeg;base64,${data.image}`, img => {
                    uniforms.vidTexture.value = img;
				})
				showStream(data.image);
			})
		}

		function updateUniform (numBlob) {
			// console.log(numBlob)
			var crowd = document.getElementById( 'crowd' );
			var alone = document.getElementById( 'alone' );

			var numIndicator = document.getElementById('numBlob');
			numIndicator.innerHTML = 'number of people: ' + numBlob;

			var newTexture;

			if (numBlob > 0) {
				newTexture = new THREE.VideoTexture( alone );
			} else {
				newTexture = new THREE.VideoTexture( crowd );
			}

			return (
				mat.uniforms.cityTexture.value = newTexture
            )
		}

		function drawBlob(predictions) {
			let canvas = document.getElementById("obj");
			let ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx.fillStyle = "rgba(0,0,0,0)";

			const font = "12px sans-serif";
		    ctx.font = font;
		    ctx.textBaseline = "top";

			predictions.forEach( prediction => {
				const x = prediction.bbox[0];
				const y = prediction.bbox[1];
				const width = prediction.bbox[2];
				const height = prediction.bbox[3];
				ctx.strokeStyle = "#00ffff";
				ctx.lineWidth = 2;
				ctx.strokeRect(x, y, width, height);

				//label
				ctx.fillStyle = "#00FFFF";
			    const textWidth = ctx.measureText(prediction.class).width;
			    const textHeight = parseInt(font, 10); // base 10
			    ctx.fillRect(x, y, textWidth + 4, textHeight + 4);
			    //text
			    ctx.fillStyle = "#000000";
      			ctx.fillText(prediction.class, x, y);
			});
		}

		const detectFrame = (img, model) => {
			model.detect(img).then(predictions => {
				// console.log(predictions.length)
				numBlob = predictions.length;
				drawBlob(predictions);
				requestAnimationFrame(() => {
					detectFrame(img, model);
					animate();
				});
			})
		}

		function init(model) {

		///////// LUT PREP ////////////

			lutTextures.forEach((info) => {
			    if (!info.size) {
			      //    'foo-s16.png' = size:16, filter: true
			      //    'bar-s8n.png' = size:8, filter: false
			      const m = /-s(\d+)(n*)\.[^.]+$/.exec(info.url);
			      if (m) {
			        info.size = parseInt(m[1]);
			        info.filter = info.filter === undefined ? m[2] !== 'n' : info.filter;
			      }
			    }

			    info.texture = makeLUTTexture(info);
			});

			const lutNameIndexMap = {};
			
			lutTextures.forEach((info, ndx) => {
			    lutNameIndexMap[info.name] = ndx;
			});

			lutSettings = {
			  lut: lutNameIndexMap.handmaids,
			};

			const gui = new GUI({ width: 300 });
			gui.add(lutSettings, 'lut', lutNameIndexMap);

		 ///////// END LUT PREP ////////////

			streamPreviewEle = document.getElementById('video');

			//took tensorflow out for now
			// detectFrame(streamPreviewEle, model)

			container = document.getElementById('container');
			camera = new THREE.PerspectiveCamera( 45, 0.56, 1, 1000 );
			camera.position.z = 6.4;
			scene = new THREE.Scene();

			textureLoader = new THREE.TextureLoader();
			var texture = new THREE.VideoTexture(streamPreviewEle);
            texture.minFilter = THREE.LinearFilter;

			var city = document.getElementById( 'alone' );
            var cityTexture = new THREE.VideoTexture( city );
            cityTexture.minFilter = THREE.LinearFilter;

			uniforms = {
                resolution: {value: new THREE.Vector2()},
                vidTexture: {type: "t", value: texture},
                cityTexture: {value: cityTexture}
            }

            mat = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragment_shader').textContent
            });

			var geom = new THREE.PlaneGeometry(3, 6);
			mesh = new THREE.Mesh( geom, mat );
			scene.add(mesh);

            canvas = document.createElement( 'canvas' );
            context = canvas.getContext( 'webgl2', { alpha: false } );
            
            renderer = new THREE.WebGLRenderer( { antialias: true, canvas: canvas, context: context } );
			renderer.setSize( 800, 400 );

            container.appendChild( renderer.domElement );


        ///////// ADD EFFECT TO RENDERER ////////////

            effectLUT = new ShaderPass(lutShader);
			effectLUT.renderToScreen = true;

			effectLUTNearest = new ShaderPass(lutNearestShader);
  			effectLUTNearest.renderToScreen = true;

			const renderBG = new RenderPass(scene, camera);
			const rtParameters = {
			    minFilter: THREE.LinearFilter,
			    magFilter: THREE.LinearFilter,
			    format: THREE.RGBFormat,
			};
			  
			composer = new EffectComposer(renderer, new THREE.WebGLRenderTarget(1, 1, rtParameters));
			composer.addPass(renderBG);
			composer.addPass(effectLUT);
			composer.addPass(effectLUTNearest);
			composer.setSize(canvas.width, canvas.height);

		///////// END ADD EFFECT TO RENDERER ////////////

			setupIO();
			animate();

		}

		function animate() {
			requestAnimationFrame( animate );
		    render();
        }

		function render() {
			const lutInfo = lutTextures[ lutSettings.lut ];
			const effect = lutInfo.filter ? effectLUT : effectLUTNearest;
			effectLUT.enabled = lutInfo.filter;
			effectLUTNearest.enabled = !lutInfo.filter;

			const lutTexture = lutInfo.texture;
			effect.uniforms.lutMap.value = lutTexture;
			effect.uniforms.lutMapSize.value = lutInfo.size;

			mat.uniforms.needsUpdate = true;
		    updateUniform(lutSettings.lut); // can also update on numBlob

            composer.render();
		}

	</script>
</body>
</html>