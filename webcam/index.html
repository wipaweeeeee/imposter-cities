<!DOCTYPE html>
<html>
<head>
		<title>Imposter Cities</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>	
			body { margin: 0; }

			#obj {
				height: 120px;
				position: absolute;
				left: 0;
			}

			#numBlob {
				padding: 20px;
				font-family: sans-serif;
			}

		</style>
	</head>
<body>

	<div id="numBlob"></div>
	<canvas id="obj"></canvas>
	<img id="video" height="120" src="cat.jpeg"></img>
	<video id="crowd" height="120" muted autoPlay loop>
	  <source src="unforgiven.mp4" type="video/mp4">
	</video>

	<video id="alone" height="120" muted autoPlay loop>
	  <source src="brokeback.mp4" type="video/mp4">
	</video>

	
	<div id="container"></div>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"> </script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"> </script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js"></script>

	<!------------- SHADER -------------->
	<script id="fragment_shader" type="x-shader/x-fragment">
        uniform float time;
        uniform sampler2D vidTexture;
		uniform sampler2D cityTexture;
		uniform vec2 aspectRatio;
        varying vec2 vUv;

        void main(  ) {
			vec2 position = vec2(vUv.x + 0.05, vUv.y);

            vec4 bg = texture2D(cityTexture,vec2(position.x,position.y));
            vec4 fg = texture2D(vidTexture,vec2(position.x,position.y));

            float maxrb = max( fg.r, fg.b );
    		float k = clamp( (fg.g-maxrb) * 2.0, 0.0, 1.0 );

    		float dg = fg.g; 
    		fg.g = min( fg.g, maxrb * 0.8 ); 
    		fg += dg - fg.g;

			//gl_FragColor = fg;
            gl_FragColor = mix(fg, bg, k);
        }

    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main()
        {
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

<!------------- THREE -------------->
	<script>
		var container, camera, scene, renderer, mesh, mat, canvas, context;
		var uniforms, textureLoader;
		var streamPreviewEle;
		var numBlob;

		window.addEventListener('load', () => {
			cocoSsd.load().then(model => {
				init(model);
			});
		});

		async function showStream(img){
			streamPreviewEle.src = `data:image/jpeg;base64,${img}`;
		}

		function setupIO() {
            console.log('setting up IO')
			const socket = io.connect();
			socket.on('data', (data) => {
				textureLoader.load(`data:image/jpeg;base64,${data.image}`, img => {
                    uniforms.vidTexture.value = img;
				})
				showStream(data.image);
			})
		}

		function updateUniform (numBlob) {
			// console.log(numBlob)
			var crowd = document.getElementById( 'crowd' );
			var alone = document.getElementById( 'alone' );

			var numIndicator = document.getElementById('numBlob');
			numIndicator.innerHTML = 'number of people: ' + numBlob;

			var newTexture;

			if (numBlob > 1) {
				newTexture = new THREE.VideoTexture( crowd );
			} else {
				newTexture = new THREE.VideoTexture( alone );
			}

			return (
				mat.uniforms.cityTexture.value = newTexture
            )
		}

		function drawBlob(predictions) {
			let canvas = document.getElementById("obj");
			let ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx.fillStyle = "rgba(0,0,0,0)";

			const font = "12px sans-serif";
		    ctx.font = font;
		    ctx.textBaseline = "top";

			predictions.forEach( prediction => {
				const x = prediction.bbox[0];
				const y = prediction.bbox[1];
				const width = prediction.bbox[2];
				const height = prediction.bbox[3];
				ctx.strokeStyle = "#00ffff";
				ctx.lineWidth = 2;
				ctx.strokeRect(x, y, width, height);

				//label
				ctx.fillStyle = "#00FFFF";
			    const textWidth = ctx.measureText(prediction.class).width;
			    const textHeight = parseInt(font, 10); // base 10
			    ctx.fillRect(x, y, textWidth + 4, textHeight + 4);
			    //text
			    ctx.fillStyle = "#000000";
      			ctx.fillText(prediction.class, x, y);
			});
		}

		const detectFrame = (img, model) => {
			model.detect(img).then(predictions => {
				// console.log(predictions.length)
				numBlob = predictions.length;
				drawBlob(predictions);
				requestAnimationFrame(() => {
					detectFrame(img, model);
					animate();
				});
			})
		}

		function init(model) {
			streamPreviewEle = document.getElementById('video');
			detectFrame(streamPreviewEle, model)
			container = document.getElementById('container');
			camera = new THREE.PerspectiveCamera( 45, 800/600, 1, 1000 );
			camera.position.z = 2;
			scene = new THREE.Scene();

			textureLoader = new THREE.TextureLoader();
			var texture = new THREE.VideoTexture(streamPreviewEle);
            texture.minFilter = THREE.LinearFilter;

			var city = document.getElementById( 'crowd' );
            var cityTexture = new THREE.VideoTexture( city );
            cityTexture.minFilter = THREE.LinearFilter;

			uniforms = {
                resolution: {value: new THREE.Vector2()},
                vidTexture: {type: "t", value: texture},
				cityTexture: {value: cityTexture}
            }

            mat = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragment_shader').textContent
            });

			var geom = new THREE.PlaneGeometry(2*2.35, 2); // video aspect ratio
			mesh = new THREE.Mesh( geom, mat );
			scene.add(mesh);

			var loader = new THREE.TextureLoader();
			var treeMat = new THREE.MeshBasicMaterial({
				map: loader.load('./tree.jpg'),
				alphaMap: loader.load('./tree_alpha.jpg'),
				transparent: true
			});

			var treeGeom = new THREE.PlaneGeometry( 1.3, 1.3 );
			let treeMesh = new THREE.Mesh( treeGeom, treeMat );
			treeMesh.position.set(1.1,0,0)
			scene.add(treeMesh);


            canvas = document.createElement( 'canvas' );
            context = canvas.getContext( 'webgl2', { alpha: false } );
            

            renderer = new THREE.WebGLRenderer( { antialias: true, canvas: canvas, context: context } );
			renderer.setClearColor( 0xffffff);
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( 800, 600 );

            container.appendChild( renderer.domElement );

			setupIO();
			// animate();
			
		}

		function animate() {
			// requestAnimationFrame( animate );
		    render();
		    // ts();

		    mat.uniforms.needsUpdate = true;
		    updateUniform(numBlob);
        }

		function render() {
            renderer.render( scene, camera );
		}

	</script>
</body>
</html>